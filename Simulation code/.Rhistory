}#k
}#j
}#i
} else {
for ( i in 1:max_age) {
for ( k in 1:2 ) { #k indexes learning strat
n[ i , 1 , k ] <- n[ i , 1 , k ] + u * n[ i , 2 , k ]
n[ i , 2 , k ] <- (1-u) * n[ i , 2 , k ]
}#k
}#j
}
# learning
# each juvenile gets a chance to learn, either individually or socially
for ( k in 1:2 ) {
if ( n[1,1,k]>0 ){
if ( k==1 ){
#Individual Learners
p_successful_ind <- n[1,1,k] * z
n[1,1,k] <- n[1,1,k] - p_successful_ind
n[1,2,k] <- p_successful_ind
} else {
#Social Learners
#Proportion of each age class
if (max_age == 2){
p_successful_soc <- sum(n[2,2,])/sum(n[2,,])
} else {
a <- c()
a[1] <- 0
for (j in 2:max_age) {
a[j]  <- sum(n[j,,])/sum(n[2:max_age,,])
}
#Proportion of adaptive behavior in each age class
q <- c()
for (j in 1:max_age) {
q[j]  <- sum(n[j,2,])/sum(n[j,,])
}
p_successful_soc <- sum((a^2)*q) #Equal pairs
for (i in 3:max_age) {
for (j in 2:(i-1)) {
p_successful_soc <- p_successful_soc + 2 * a[i]  *a[j] * ( q[i] * (phi/(phi+1))  + q[j] * (1/(phi+1)) )
}
}
}
n_successful_soc <- n[1,1,k] * p_successful_soc * (1-SL_Error)
n[1,1,k] <- n[1,1,k] - n_successful_soc
n[1,2,k] <- n_successful_soc
}
}
}#k
# Store info in output objects
if (max_age == 2){
lambda[t] <- sum(n[1,,])
lambdaIL[t] <- sum(n[1,,1]) / N_IL
lambdaSL[t] <- sum(n[1,,2]) / N_SL
} else {
lambda[t] <- sum(n)
lambdaIL[t] <- sum(n[,,1]) / N_IL
lambdaSL[t] <- sum(n[,,2]) / N_SL
}
Juveniles[t] <- sum(n[1,,])
PropAdapt[t] <- sum(n[,2,]/sum(n))
PropIL[t] <- sum(n[,,1]/sum(n))
for (x in 1:max_age) {
AdaptedPerAge[x,t] <- sum(n[x,2,]/sum(n[x,,]))
}
#Renormalize population size
if (max_age == 2){
n[1,,] <- n[1,,]/sum(n[1,,])
} else {
n <- n/sum(n)
}
}#t
return(list(n=n,
lambda=lambda,
lambdaIL=lambdaIL,
lambdaSL=lambdaSL,
Juveniles=Juveniles,
Adapt=PropAdapt,
IL= PropIL,
SL= 1- PropIL,
Change=EnvChange,
AdaptedPerAge=AdaptedPerAge))
}
result <- recurs()
par(mfrow=c(1,2))
plot(apply(result$AdaptedPerAge, 1, mean), type = "l", ylim = c(0,1), ylab = "Proportion Adapted", xlab = "Age")
plot(result$lambda/max(result$lambda), type= "l", ylim = c(0,1), ylab = "", lty =1, xlab = "Time")
par(new=TRUE)
plot(result$SL,type = "l", ylim = c(0,1), col="green",  yaxt = "n", ylab = "", lty =2)
par(new=TRUE)
plot(result$Adapt, type = "l", ylim = c(0,1), col = "red", yaxt = "n", ylab = "", lty =3)
legend("bottomright", c("Fitness", "Prop Adapted", "Prop SL"), col = c("black", "red", "green"), lty = 1:3, cex = 0.6)
# Recursions to simulate age-structured social learning model
# Set IL_Only to "Yes" for population with only individual learners
# Set Stoch_E to "Yes" for stochastically changing environment
# max_age = 2 corresponds to discrete-generation model.
# Includes code for simple plot with time dynamics in the end
# Run this function with respective parameter values to reproduce
# results shown in Fig.1 and Fig.2
# Simulation function
recurs <- function( tmax=1000 ,           # Timesteps
max_age = 80  ,     # Maximum age (max_age = 2 corresponds to Rogers model)
b=c(0.35,0.35) ,    # Fertility rates for non-adapted and adapted individuals
s=c(0.85,0.93),     # Survival rates for non-adapted and adapted individuals
u=0.1,             # Rate of environmental change
z=0.5,                # Success rate of individual learning
c=0.05,             # Recruitment cost of individual learning
phi = 1,            # Age bias (phi = 1 means unbiased)
SL_Error = 0,       # Error rate in social learning
IL_Only = "No",     # Individual learners only?
Stoch_E = "No") {  # Stochastically changing environment?
#Create population array with age-strategy classes
n <- array( 0 , dim=c( max_age , 2 , 2) ) # age, adapted = 2, Learning Strategy , IL = 1
#Half IL and half SL
if ( IL_Only == "Yes"){
if (max_age == 2){
n[1,1,1] <- 1
n[1,1,2] <- 0
} else {
n[,1,1] <- 1/max_age
n[,1,2] <- 0
}
} else {
if (max_age == 2){
n[1,1,1] <- 0.5
n[1,1,2] <- 0.5
} else {
n[,1,1] <- 0.5/max_age
n[,1,2] <- 0.5/max_age
}
}
N <- sum(n)
#Output objects
lambda <- c()
lambdaSL <- c()
lambdaIL <- c()
Juveniles <- c()
PropAdapt <- c()
AdaptedPerAge <- matrix(nrow = max_age, ncol = tmax)
PropIL <- c()
EnvChange <- c()
for ( t in 1:tmax ) {
print(t)
#Number of individuals
N <- sum(n)
if (max_age == 2){
N_IL <- sum(n[1,,1])
N_SL <- sum(n[1,,2])
} else {
N_IL <- sum(n[,,1])
N_SL <- sum(n[,,2])
}
# life cycle:
# age (survival)
# reproduction
# environment change
# learning
# aging
# loop over age classes, in reverse
for ( i in (max_age-1):1 ) {
for ( j in 1:2 ) { #j indexes non-adapted/adapted
for (k in 1:2) { #k indexes learning strat
if (i==1 & k==1){ #Individual learning juveniles pay recruitment cost
n[ i+1 , j , k]  <- n[ i , j , k] * s[j] * (1-c)
} else {
n[ i+1 , j , k] <- n[ i , j , k] * s[j]
}
}#k
}#j
}#i
#Empty juvenile slots
for ( j in 1:2 ){
for ( k in 1:2 ){
for (l in 1:2) {
n[ 1 , j , k ] <- 0
}#j
}#k
}#l
# reproduction --- fill age class 1
# babies get stored in a vector
classes <- expand.grid(age=2:max_age, j=1:2, k=1:2)
babies <- rep(0, nrow(classes))
for ( i in 2:max_age ) {
for ( j in 1:2 ){
for ( k in 1:2 ) {
n_parents <- n[ i , j , k]
if (n_parents > 0){
nn <- n_parents * b[j]
if ( nn > 0 ) {
#Assign to vector
babies[which(classes$age==i & classes$j==j & classes$k==k)] <- babies[which(classes$age==i & classes$j==j & classes$k==k)] + nn
}
}
}#k
}#j
}#i
#Assign babies to juvenile class
for ( k in 1:2 ) {
n[1,1, k] <- sum(babies[which(classes$k==k)])
}
#environmental change
if (Stoch_E == "Yes") {
ut <- ifelse( runif(1) < u , 1 , 0 )
EnvChange[t] <- ifelse(ut==1, 1, 0)
if (ut == 1){
for ( i in 1:max_age) {
for ( k in 1:2 ) { #k indexes learning strat
n[ i , 1 , k ] <- sum(n[ i ,  , k ])
n[ i , 2 , k ] <- 0
}#k
}#j
}#i
} else {
for ( i in 1:max_age) {
for ( k in 1:2 ) { #k indexes learning strat
n[ i , 1 , k ] <- n[ i , 1 , k ] + u * n[ i , 2 , k ]
n[ i , 2 , k ] <- (1-u) * n[ i , 2 , k ]
}#k
}#j
}
# learning
# each juvenile gets a chance to learn, either individually or socially
for ( k in 1:2 ) {
if ( n[1,1,k]>0 ){
if ( k==1 ){
#Individual Learners
p_successful_ind <- n[1,1,k] * z
n[1,1,k] <- n[1,1,k] - p_successful_ind
n[1,2,k] <- p_successful_ind
} else {
#Social Learners
#Proportion of each age class
if (max_age == 2){
p_successful_soc <- sum(n[2,2,])/sum(n[2,,])
} else {
a <- c()
a[1] <- 0
for (j in 2:max_age) {
a[j]  <- sum(n[j,,])/sum(n[2:max_age,,])
}
#Proportion of adaptive behavior in each age class
q <- c()
for (j in 1:max_age) {
q[j]  <- sum(n[j,2,])/sum(n[j,,])
}
p_successful_soc <- sum((a^2)*q) #Equal pairs
for (i in 3:max_age) {
for (j in 2:(i-1)) {
p_successful_soc <- p_successful_soc + 2 * a[i]  *a[j] * ( q[i] * (phi/(phi+1))  + q[j] * (1/(phi+1)) )
}
}
}
n_successful_soc <- n[1,1,k] * p_successful_soc * (1-SL_Error)
n[1,1,k] <- n[1,1,k] - n_successful_soc
n[1,2,k] <- n_successful_soc
}
}
}#k
# Store info in output objects
if (max_age == 2){
lambda[t] <- sum(n[1,,])
lambdaIL[t] <- sum(n[1,,1]) / N_IL
lambdaSL[t] <- sum(n[1,,2]) / N_SL
} else {
lambda[t] <- sum(n)
lambdaIL[t] <- sum(n[,,1]) / N_IL
lambdaSL[t] <- sum(n[,,2]) / N_SL
}
Juveniles[t] <- sum(n[1,,])
PropAdapt[t] <- sum(n[,2,]/sum(n))
PropIL[t] <- sum(n[,,1]/sum(n))
for (x in 1:max_age) {
AdaptedPerAge[x,t] <- sum(n[x,2,]/sum(n[x,,]))
}
#Renormalize population size
if (max_age == 2){
n[1,,] <- n[1,,]/sum(n[1,,])
} else {
n <- n/sum(n)
}
}#t
return(list(n=n,
lambda=lambda,
lambdaIL=lambdaIL,
lambdaSL=lambdaSL,
Juveniles=Juveniles,
Adapt=PropAdapt,
IL= PropIL,
SL= 1- PropIL,
Change=EnvChange,
AdaptedPerAge=AdaptedPerAge))
}
result <- recurs()
par(mfrow=c(1,2))
plot(apply(result$AdaptedPerAge, 1, mean), type = "l", ylim = c(0,1), ylab = "Proportion Adapted", xlab = "Age")
plot(result$lambda/max(result$lambda), type= "l", ylim = c(0,1), ylab = "", lty =1, xlab = "Time")
par(new=TRUE)
plot(result$SL,type = "l", ylim = c(0,1), col="green",  yaxt = "n", ylab = "", lty =2, xlab = "")
par(new=TRUE)
plot(result$Adapt, type = "l", ylim = c(0,1), col = "red", yaxt = "n", ylab = "", lty =3, xlab = "")
legend("bottomright", c("Fitness", "Prop Adapted", "Prop SL"), col = c("black", "red", "green"), lty = 1:3, cex = 0.6)
######
#####
####
###
##
# SPATIAL MODEL
##
###
####
#####
######
seq_spatial<-expand.grid(Nsim=10, tmax=7000, NmaxPerGroup=500, max_age=80, sigma= c(0.6, 0.65, 0.7, 0.75, 0.8, 0.85, 0.9, 0.95, 1), m = c(0.001, 0.005, 0.01, 0.05, 0.1, 0.15, 0.2, 0.25, 0.3),
z=c(0.01,0.5,1),c= c(0.05, 0.1, 0.2), mu_pi = 0.005,mu_phi= 0.005, SL_Error=c(0,0.1,0.3),Nmodels = 2, NGroups=4)
#Define simulation function
sim_spatial <- function(Nsim, tmax,NmaxPerGroup,max_age, sigma, m, z, c, mu_pi,mu_phi,SL_Error,Nmodels,NGroups) {
#Create empty list for output matrices of all N=Nsim simulation runs
Combined_list <- list()
#Loop over all N=Nsim separate simulations
for(xsim in 1:Nsim){
Nmax <- NmaxPerGroup*NGroups
#Create population array with age-strategy classes
n <- array( 0 , dim=c(NGroups, max_age , 2 , 2, 2) ) # Group, age, adapted = 2, Learning Strategy , IL = 1, Age Bias, copy old = 1
#Half IL and half SL
n[,,1,1,1] <- floor(0.25*NmaxPerGroup/max_age)
n[,,1,1,2] <- floor(0.25*NmaxPerGroup/max_age)
n[,,1,2,1] <- floor(0.25*NmaxPerGroup/max_age)
n[,,1,2,2] <- floor(0.25*NmaxPerGroup/max_age)
N <- sum(n)
#Output objects
PropIL <- c()
PropOld <- c()
p_hat <- c()
s <- c(0.9 * sigma,0.9)
b <- c(1,1)
for ( t in 1:tmax ) {
#Number of individuals
N <- sum(n)
# life cycle:
# age (survival)
# reproduction
# migration
# learning
# aging
# loop over age classes, in reverse
for (h in 1:NGroups) {
for ( i in (max_age-1):1 ) {
for ( j in 1:2 ) { #j indexes non-adapted/adapted
for (k in 1:2) { #k indexes learning strat
for ( l in 1:2 ){ #l indexes age bias
if (i==1 & k==1){ #Individual learning juveniles pay recruitment cost
n[h, i+1 , j , k, l ] <- rbinom( 1 , size=n[h, i , j , k,  l ] , prob=s[j]*(1-c) )
} else {
n[h, i+1 , j , k, l ] <- rbinom( 1 , size=n[h, i , j , k,  l ] , prob=s[j] )
}
}#l
}#k
}#j
}#i
}#h
# reproduction --- fill age class 1
# produce offspring and then truncate N to Nmax by sampling from all offspring produced
for (h in 1:NGroups) {
for ( j in 1:2 ){
for ( k in 1:2 ){
for (l in 1:2) {
#Empty juvenile slots
n[h, 1 , j , k , l ] <- 0
}
}
}
}
# babies get stored in a long table, and later sample from it and inserted into n array
babies <- array(NA, dim = c(NGroups, Nmax/NGroups, 2))
# columns are [1] learning strategy [2] Age Bias
n_babies <- c()
for (h in 1:NGroups) {
n_babies[h] <- 0
n_parents <- 0
for ( i in 2:max_age ) {
for ( j in 1:2 ){
for ( k in 1:2 ) {
for (l in 1:2){
n_parents <- n[h, i , j , k, l ]
if (n_parents > 0){
nn <- rbinom( 1 , size=n_parents , prob=b[j] )
if ( nn > 0 ) {
#Assign to baby matrix with mutation
babies[h, (n_babies[h]+1):(n_babies[h]+nn) , 1 ] <- ifelse(k==1, sample(c(1,2), 1, prob = c(1-mu_pi, mu_pi)),sample(c(2,1), 1, prob = c(1-mu_pi, mu_pi)))
babies[h, (n_babies[h]+1):(n_babies[h]+nn) , 2 ] <- ifelse(l==1, sample(c(1,2), 1, prob = c(1-mu_phi, mu_phi)),sample(c(2,1), 1, prob = c(1-mu_phi, mu_phi)))
n_babies[h] <- n_babies[h] + nn
}
}
}#l
}#k
}#j
}#i
}
# put babies in first age class, according to learning strat inherited
pop_size_without_babies <- c()
baby_slots <- c()
for (h in 1:NGroups) {
pop_size_without_babies[h] <- sum(n[h,,,,])
baby_slots[h] <- NmaxPerGroup - pop_size_without_babies[h]
baby_slots[h] <- min( baby_slots[h] , n_babies[h] )
}
# sample babies and put them into n[h,1,1,,] - all are born non-adapted
for (h in 1:NGroups) {
if ( baby_slots[h] > 0 ) {
# shorten and shuffle babies list
Newborns <- babies[h, 1:n_babies[h] , ]
Newborns <- Newborns[sample(1:n_babies[h]) , ]
for ( i in 1:baby_slots[h] ) {
# go in order and slot in babies
n[h, 1 , 1 , Newborns[i,1],Newborns[i,2]] <- n[h, 1 , 1 , Newborns[i,1],Newborns[i,2]] + 1
}
}
}
#Migration
# columns are [1] learning strategy [2] Age Bias and [3] Age
MigrantPool <- array(NA, dim = c(NGroups, Nmax/NGroups, 3))
n_Migrants <- c()
for (h in 1:NGroups) {
n_Migrants[h] <- 0
for ( i in 2:max_age ) {
for ( j in 1:2 ){
for ( k in 1:2 ) {
for (l in 1:2){
nn <- rbinom( 1 , size=n[h,i,j,k,l] , prob=m )
if ( nn > 0 ) {
#Assign to migrant matrix
MigrantPool[h, (n_Migrants[h]+1):(n_Migrants[h]+nn) , 1 ] <- k
MigrantPool[h, (n_Migrants[h]+1):(n_Migrants[h]+nn) , 2 ] <- l
MigrantPool[h, (n_Migrants[h]+1):(n_Migrants[h]+nn) , 3 ] <- i
n_Migrants[h] <- n_Migrants[h] + nn
#Remove individuals from Groups
n[h,i,j,k,l] <- n[h,i,j,k,l] - nn
}
}#l
}#k
}#j
}#i
}
Migrants <- c()
for (h in 1:NGroups) {
Migrants <- rbind(Migrants, MigrantPool[h, 1:n_Migrants[h] , ])
}
Migrants <- Migrants[sample(1:nrow(Migrants)) , ]
#Assign Migrants to groups keeping group size constant
#Migrants are not adapted
for (h in 1:NGroups) {
AlreadyGone <- sum(n_Migrants[which((1:NGroups)<h)])
if (n_Migrants[h] > 0){
for (i in (AlreadyGone+1):sum(n_Migrants[which((1:NGroups)<=h)])) {
n[h, Migrants[i,3] , 1 , Migrants[i,1],Migrants[i,2]] <- n[h, Migrants[i,3] , 1 , Migrants[i,1],Migrants[i,2]] + 1
}
}
}
# learning
# each juvenile gets a chance to learn, either individually or socially
for (h in 1:NGroups) {
for ( k in 1:2 ) {
for (l in 1:2) {
if ( n[h,1,1,k,l]>0 ){
if ( k==1 ){
#Individual Learners
n_successful_ind <- rbinom( 1 , size=n[h,1,1,k,l] , prob=z)
n[h,1,1,k,l] <- n[h,1,1,k,l] - n_successful_ind
n[h,1,2,k,l] <- n_successful_ind
} else {
#Social Learners
#Proportion of each age class
Age_Prop <- c()
Age_Prop[1] <- 0
for (j in 2:max_age) {
Age_Prop[j]  <- sum(n[h,j,,,])/sum(n[h,2:max_age,,,])
}
n_successful_soc <- 0
for (x in 1:n[h,1,1,k,l]) {
Age_Models <- sample(1:max_age, Nmodels, prob=Age_Prop, replace = TRUE)
#Select age class depending on age bias
Selected <- ifelse(l==1, max(Age_Models), min(Age_Models))
#Sample from selected age class proportional to proportion of adapted individuals
kk <- rbinom(1,size=1, prob = sum(n[h,Selected,2,,])/sum(n[h,Selected,,,]))
n_successful_soc <- n_successful_soc + kk
}
n_successful_soc <- rbinom(1, n_successful_soc, (1-SL_Error))
n[h,1,1,k,l] <- n[h,1,1,k,l] - n_successful_soc
n[h,1,2,k,l] <- n_successful_soc
}
}
}#l
}#k
}#h
# Store info in output objects
PropIL[t] <- sum(n[,,,1,]/sum(n))
PropOld[t] <- sum(n[,,,,1]/sum(n))
p_hat[t] <- sum(n[,1,2,,])/sum(n[,1,,,])
}#t
Combined_list[[xsim]]<- list(PropIL= PropIL,
PropOld=PropOld,
p_hat = p_hat)
}#xsim
return(Combined_list)
}
# pass to mclapply
result_spatial <- mclapply(
1:nrow(seq_spatial) ,
function(i) sim_spatial(seq_spatial$Nsim[i], seq_spatial$tmax[i], seq_spatial$NmaxPerGroup[i] , seq_spatial$max_age[i],
seq_spatial$sigma[i], seq_spatial$m[i], seq_spatial$z[i], seq_spatial$c[i], seq_spatial$mu_pi[i],
seq_spatial$mu_phi[i],seq_spatial$SL_Error[i], seq_spatial$Nmodels[i], seq_spatial$NGroups[i]),
mc.cores=1)
